// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod fb {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    // struct Header, aligned to 4
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Header(pub [u8; 36]);
    impl Default for Header {
        fn default() -> Self {
            Self([0; 36])
        }
    }
    impl core::fmt::Debug for Header {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Header")
                .field("version", &self.version())
                .field("domain", &self.domain())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Header {}
    impl<'a> flatbuffers::Follow<'a> for Header {
        type Inner = &'a Header;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Header>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Header {
        type Inner = &'a Header;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Header>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Header {
        type Output = Header;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src =
                ::core::slice::from_raw_parts(self as *const Header as *const u8, Self::size());
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for Header {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Header {
        #[allow(clippy::too_many_arguments)]
        pub fn new(version: u32, domain: &[u8; 32]) -> Self {
            let mut s = Self([0; 36]);
            s.set_version(version);
            s.set_domain(domain);
            s
        }

        pub fn version(&self) -> u32 {
            let mut mem = core::mem::MaybeUninit::<<u32 as EndianScalar>::Scalar>::uninit();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            EndianScalar::from_little_endian(unsafe {
                core::ptr::copy_nonoverlapping(
                    self.0[0..].as_ptr(),
                    mem.as_mut_ptr() as *mut u8,
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
                mem.assume_init()
            })
        }

        pub fn set_version(&mut self, x: u32) {
            let x_le = x.to_little_endian();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid value in this slot
            unsafe {
                core::ptr::copy_nonoverlapping(
                    &x_le as *const _ as *const u8,
                    self.0[0..].as_mut_ptr(),
                    core::mem::size_of::<<u32 as EndianScalar>::Scalar>(),
                );
            }
        }

        pub fn domain(&'a self) -> flatbuffers::Array<'a, u8, 32> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 4) }
        }

        pub fn set_domain(&mut self, items: &[u8; 32]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 4, items) };
        }

        pub fn unpack(&self) -> HeaderT {
            HeaderT {
                version: self.version(),
                domain: self.domain().into(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct HeaderT {
        pub version: u32,
        pub domain: [u8; 32],
    }
    impl HeaderT {
        pub fn pack(&self) -> Header {
            Header::new(self.version, &self.domain)
        }
    }

    // struct Input, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Input(pub [u8; 96]);
    impl Default for Input {
        fn default() -> Self {
            Self([0; 96])
        }
    }
    impl core::fmt::Debug for Input {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Input")
                .field("cv", &self.cv())
                .field("nf", &self.nf())
                .field("rk", &self.rk())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Input {}
    impl<'a> flatbuffers::Follow<'a> for Input {
        type Inner = &'a Input;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Input>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Input {
        type Inner = &'a Input;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Input>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Input {
        type Output = Input;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src =
                ::core::slice::from_raw_parts(self as *const Input as *const u8, Self::size());
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for Input {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Input {
        #[allow(clippy::too_many_arguments)]
        pub fn new(cv: &[u8; 32], nf: &[u8; 32], rk: &[u8; 32]) -> Self {
            let mut s = Self([0; 96]);
            s.set_cv(cv);
            s.set_nf(nf);
            s.set_rk(rk);
            s
        }

        pub fn cv(&'a self) -> flatbuffers::Array<'a, u8, 32> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_cv(&mut self, items: &[u8; 32]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }

        pub fn nf(&'a self) -> flatbuffers::Array<'a, u8, 32> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 32) }
        }

        pub fn set_nf(&mut self, items: &[u8; 32]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 32, items) };
        }

        pub fn rk(&'a self) -> flatbuffers::Array<'a, u8, 32> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 64) }
        }

        pub fn set_rk(&mut self, items: &[u8; 32]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 64, items) };
        }

        pub fn unpack(&self) -> InputT {
            InputT {
                cv: self.cv().into(),
                nf: self.nf().into(),
                rk: self.rk().into(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct InputT {
        pub cv: [u8; 32],
        pub nf: [u8; 32],
        pub rk: [u8; 32],
    }
    impl InputT {
        pub fn pack(&self) -> Input {
            Input::new(&self.cv, &self.nf, &self.rk)
        }
    }

    // struct Signature, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Signature(pub [u8; 64]);
    impl Default for Signature {
        fn default() -> Self {
            Self([0; 64])
        }
    }
    impl core::fmt::Debug for Signature {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Signature")
                .field("r_part", &self.r_part())
                .field("s_part", &self.s_part())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Signature {}
    impl<'a> flatbuffers::Follow<'a> for Signature {
        type Inner = &'a Signature;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Signature>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Signature {
        type Inner = &'a Signature;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Signature>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Signature {
        type Output = Signature;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src =
                ::core::slice::from_raw_parts(self as *const Signature as *const u8, Self::size());
            dst.copy_from_slice(src);
        }
    }

    impl<'a> flatbuffers::Verifiable for Signature {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Signature {
        #[allow(clippy::too_many_arguments)]
        pub fn new(r_part: &[u8; 32], s_part: &[u8; 32]) -> Self {
            let mut s = Self([0; 64]);
            s.set_r_part(r_part);
            s.set_s_part(s_part);
            s
        }

        pub fn r_part(&'a self) -> flatbuffers::Array<'a, u8, 32> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_r_part(&mut self, items: &[u8; 32]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }

        pub fn s_part(&'a self) -> flatbuffers::Array<'a, u8, 32> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 32) }
        }

        pub fn set_s_part(&mut self, items: &[u8; 32]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 32, items) };
        }

        pub fn unpack(&self) -> SignatureT {
            SignatureT {
                r_part: self.r_part().into(),
                s_part: self.s_part().into(),
            }
        }
    }

    #[derive(Debug, Clone, PartialEq, Default)]
    pub struct SignatureT {
        pub r_part: [u8; 32],
        pub s_part: [u8; 32],
    }
    impl SignatureT {
        pub fn pack(&self) -> Signature {
            Signature::new(&self.r_part, &self.s_part)
        }
    }

    pub enum BallotOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Ballot<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Ballot<'a> {
        type Inner = Ballot<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Ballot<'a> {
        pub const VT_HEADER: flatbuffers::VOffsetT = 4;
        pub const VT_INPUTS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_PAYLOAD: flatbuffers::VOffsetT = 10;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Ballot { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BallotArgs<'args>,
        ) -> flatbuffers::WIPOffset<Ballot<'bldr>> {
            let mut builder = BallotBuilder::new(_fbb);
            builder.add_amount(args.amount);
            if let Some(x) = args.payload {
                builder.add_payload(x);
            }
            if let Some(x) = args.inputs {
                builder.add_inputs(x);
            }
            if let Some(x) = args.header {
                builder.add_header(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> BallotT {
            let header = self.header().map(|x| x.unpack());
            let inputs = self
                .inputs()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let amount = self.amount();
            let payload = self.payload().map(|x| x.into_iter().collect());
            BallotT {
                header,
                inputs,
                amount,
                payload,
            }
        }

        #[inline]
        pub fn header(&self) -> Option<&'a Header> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Header>(Ballot::VT_HEADER, None) }
        }
        #[inline]
        pub fn inputs(&self) -> Option<flatbuffers::Vector<'a, Input>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, Input>>>(
                        Ballot::VT_INPUTS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(Ballot::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn payload(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Ballot::VT_PAYLOAD,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Ballot<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Header>("header", Self::VT_HEADER, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, Input>>>(
                    "inputs",
                    Self::VT_INPUTS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "payload",
                    Self::VT_PAYLOAD,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BallotArgs<'a> {
        pub header: Option<&'a Header>,
        pub inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Input>>>,
        pub amount: u64,
        pub payload: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for BallotArgs<'a> {
        #[inline]
        fn default() -> Self {
            BallotArgs {
                header: None,
                inputs: None,
                amount: 0,
                payload: None,
            }
        }
    }

    pub struct BallotBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BallotBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_header(&mut self, header: &Header) {
            self.fbb_
                .push_slot_always::<&Header>(Ballot::VT_HEADER, header);
        }
        #[inline]
        pub fn add_inputs(
            &mut self,
            inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Input>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Ballot::VT_INPUTS, inputs);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(Ballot::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_payload(
            &mut self,
            payload: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Ballot::VT_PAYLOAD, payload);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BallotBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BallotBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Ballot<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Ballot<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Ballot");
            ds.field("header", &self.header());
            ds.field("inputs", &self.inputs());
            ds.field("amount", &self.amount());
            ds.field("payload", &self.payload());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BallotT {
        pub header: Option<HeaderT>,
        pub inputs: Option<Vec<InputT>>,
        pub amount: u64,
        pub payload: Option<Vec<u8>>,
    }
    impl Default for BallotT {
        fn default() -> Self {
            Self {
                header: None,
                inputs: None,
                amount: 0,
                payload: None,
            }
        }
    }
    impl BallotT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Ballot<'b>> {
            let header_tmp = self.header.as_ref().map(|x| x.pack());
            let header = header_tmp.as_ref();
            let inputs = self.inputs.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack()).collect();
                _fbb.create_vector(&w)
            });
            let amount = self.amount;
            let payload = self.payload.as_ref().map(|x| _fbb.create_vector(x));
            Ballot::create(
                _fbb,
                &BallotArgs {
                    header,
                    inputs,
                    amount,
                    payload,
                },
            )
        }
    }
    pub enum ProofOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Proof<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Proof<'a> {
        type Inner = Proof<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Proof<'a> {
        pub const VT_DATA: flatbuffers::VOffsetT = 4;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Proof { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args ProofArgs<'args>,
        ) -> flatbuffers::WIPOffset<Proof<'bldr>> {
            let mut builder = ProofBuilder::new(_fbb);
            if let Some(x) = args.data {
                builder.add_data(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> ProofT {
            let data = self.data().map(|x| x.into_iter().collect());
            ProofT { data }
        }

        #[inline]
        pub fn data(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        Proof::VT_DATA,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for Proof<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "data",
                    Self::VT_DATA,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct ProofArgs<'a> {
        pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for ProofArgs<'a> {
        #[inline]
        fn default() -> Self {
            ProofArgs { data: None }
        }
    }

    pub struct ProofBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ProofBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_data(&mut self, data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Proof::VT_DATA, data);
        }
        #[inline]
        pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ProofBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            ProofBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Proof<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Proof<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Proof");
            ds.field("data", &self.data());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct ProofT {
        pub data: Option<Vec<u8>>,
    }
    impl Default for ProofT {
        fn default() -> Self {
            Self { data: None }
        }
    }
    impl ProofT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<Proof<'b>> {
            let data = self.data.as_ref().map(|x| _fbb.create_vector(x));
            Proof::create(_fbb, &ProofArgs { data })
        }
    }
    pub enum BallotWitnessOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BallotWitness<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BallotWitness<'a> {
        type Inner = BallotWitness<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BallotWitness<'a> {
        pub const VT_PROOFS: flatbuffers::VOffsetT = 4;
        pub const VT_BINDING_SIGNATURE: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BallotWitness { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BallotWitnessArgs<'args>,
        ) -> flatbuffers::WIPOffset<BallotWitness<'bldr>> {
            let mut builder = BallotWitnessBuilder::new(_fbb);
            if let Some(x) = args.binding_signature {
                builder.add_binding_signature(x);
            }
            if let Some(x) = args.proofs {
                builder.add_proofs(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> BallotWitnessT {
            let proofs = self
                .proofs()
                .map(|x| x.iter().map(|t| t.unpack()).collect());
            let binding_signature = self.binding_signature().map(|x| x.unpack());
            BallotWitnessT {
                proofs,
                binding_signature,
            }
        }

        #[inline]
        pub fn proofs(
            &self,
        ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab.get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof>>,
                >>(BallotWitness::VT_PROOFS, None)
            }
        }
        #[inline]
        pub fn binding_signature(&self) -> Option<&'a Signature> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Signature>(BallotWitness::VT_BINDING_SIGNATURE, None)
            }
        }
    }

    impl flatbuffers::Verifiable for BallotWitness<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Proof>>,
                >>("proofs", Self::VT_PROOFS, false)?
                .visit_field::<Signature>("binding_signature", Self::VT_BINDING_SIGNATURE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct BallotWitnessArgs<'a> {
        pub proofs: Option<
            flatbuffers::WIPOffset<
                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Proof<'a>>>,
            >,
        >,
        pub binding_signature: Option<&'a Signature>,
    }
    impl<'a> Default for BallotWitnessArgs<'a> {
        #[inline]
        fn default() -> Self {
            BallotWitnessArgs {
                proofs: None,
                binding_signature: None,
            }
        }
    }

    pub struct BallotWitnessBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BallotWitnessBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_proofs(
            &mut self,
            proofs: flatbuffers::WIPOffset<
                flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Proof<'b>>>,
            >,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BallotWitness::VT_PROOFS, proofs);
        }
        #[inline]
        pub fn add_binding_signature(&mut self, binding_signature: &Signature) {
            self.fbb_.push_slot_always::<&Signature>(
                BallotWitness::VT_BINDING_SIGNATURE,
                binding_signature,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BallotWitnessBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BallotWitnessBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BallotWitness<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BallotWitness<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BallotWitness");
            ds.field("proofs", &self.proofs());
            ds.field("binding_signature", &self.binding_signature());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BallotWitnessT {
        pub proofs: Option<Vec<ProofT>>,
        pub binding_signature: Option<SignatureT>,
    }
    impl Default for BallotWitnessT {
        fn default() -> Self {
            Self {
                proofs: None,
                binding_signature: None,
            }
        }
    }
    impl BallotWitnessT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<BallotWitness<'b>> {
            let proofs = self.proofs.as_ref().map(|x| {
                let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();
                _fbb.create_vector(&w)
            });
            let binding_signature_tmp = self.binding_signature.as_ref().map(|x| x.pack());
            let binding_signature = binding_signature_tmp.as_ref();
            BallotWitness::create(
                _fbb,
                &BallotWitnessArgs {
                    proofs,
                    binding_signature,
                },
            )
        }
    }
    pub enum BallotEnvelopeOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BallotEnvelope<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BallotEnvelope<'a> {
        type Inner = BallotEnvelope<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BallotEnvelope<'a> {
        pub const VT_BALLOT: flatbuffers::VOffsetT = 4;
        pub const VT_WITNESS: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BallotEnvelope { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BallotEnvelopeArgs<'args>,
        ) -> flatbuffers::WIPOffset<BallotEnvelope<'bldr>> {
            let mut builder = BallotEnvelopeBuilder::new(_fbb);
            if let Some(x) = args.witness {
                builder.add_witness(x);
            }
            if let Some(x) = args.ballot {
                builder.add_ballot(x);
            }
            builder.finish()
        }

        pub fn unpack(&self) -> BallotEnvelopeT {
            let ballot = self.ballot().map(|x| Box::new(x.unpack()));
            let witness = self.witness().map(|x| Box::new(x.unpack()));
            BallotEnvelopeT { ballot, witness }
        }

        #[inline]
        pub fn ballot(&self) -> Option<Ballot<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<Ballot>>(BallotEnvelope::VT_BALLOT, None)
            }
        }
        #[inline]
        pub fn witness(&self) -> Option<BallotWitness<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<BallotWitness>>(
                        BallotEnvelope::VT_WITNESS,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for BallotEnvelope<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<Ballot>>(
                    "ballot",
                    Self::VT_BALLOT,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<BallotWitness>>(
                    "witness",
                    Self::VT_WITNESS,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BallotEnvelopeArgs<'a> {
        pub ballot: Option<flatbuffers::WIPOffset<Ballot<'a>>>,
        pub witness: Option<flatbuffers::WIPOffset<BallotWitness<'a>>>,
    }
    impl<'a> Default for BallotEnvelopeArgs<'a> {
        #[inline]
        fn default() -> Self {
            BallotEnvelopeArgs {
                ballot: None,
                witness: None,
            }
        }
    }

    pub struct BallotEnvelopeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BallotEnvelopeBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_ballot(&mut self, ballot: flatbuffers::WIPOffset<Ballot<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<Ballot>>(
                    BallotEnvelope::VT_BALLOT,
                    ballot,
                );
        }
        #[inline]
        pub fn add_witness(&mut self, witness: flatbuffers::WIPOffset<BallotWitness<'b>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<BallotWitness>>(
                    BallotEnvelope::VT_WITNESS,
                    witness,
                );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BallotEnvelopeBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BallotEnvelopeBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BallotEnvelope<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BallotEnvelope<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BallotEnvelope");
            ds.field("ballot", &self.ballot());
            ds.field("witness", &self.witness());
            ds.finish()
        }
    }
    #[non_exhaustive]
    #[derive(Debug, Clone, PartialEq)]
    pub struct BallotEnvelopeT {
        pub ballot: Option<Box<BallotT>>,
        pub witness: Option<Box<BallotWitnessT>>,
    }
    impl Default for BallotEnvelopeT {
        fn default() -> Self {
            Self {
                ballot: None,
                witness: None,
            }
        }
    }
    impl BallotEnvelopeT {
        pub fn pack<'b, A: flatbuffers::Allocator + 'b>(
            &self,
            _fbb: &mut flatbuffers::FlatBufferBuilder<'b, A>,
        ) -> flatbuffers::WIPOffset<BallotEnvelope<'b>> {
            let ballot = self.ballot.as_ref().map(|x| x.pack(_fbb));
            let witness = self.witness.as_ref().map(|x| x.pack(_fbb));
            BallotEnvelope::create(_fbb, &BallotEnvelopeArgs { ballot, witness })
        }
    }
} // pub mod fb
